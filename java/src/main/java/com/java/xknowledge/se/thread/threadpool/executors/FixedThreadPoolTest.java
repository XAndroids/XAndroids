package com.java.xknowledge.se.thread.threadpool.executors;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * Executors.newFixedThreadPool()，固定数量线程池测试类：
 * newFixedThreadPool源码：new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,
 * new LinkedBlockingQueue<Runnable>(),threadFactory);
 * 固定线程池：核心线程数：corePoolSize = nThreads、最大线程数：maximumPoolSize = nThreads、非核心线程生命时间：keepAliveTime = 0L、阻塞队列：LinkedBlockingQueue
 *   1.只有固定的核心线程数量（corePoolSize = nThreads，LinkedBlockingQueue无界队列，理论上不会满，故不会有最大线程数，故非核心线程生命时间：keepAliveTime = 0L也没有意义）
 *   2.核心线程不会被回收，如果后续有任务执行，会继续复用；
 * //参考：https://juejin.cn/post/6844903825740922887
 */
class FixedThreadPoolTest {
    public static void main(String[] args) {
        int processors = Runtime.getRuntime().availableProcessors();
        System.out.println("processors = " + processors);
        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(processors, new MyThreadFactory());
        //前20个任务，创建processors = 4个线程，1、2、3、4执行任务，前4个任务立即执行，剩余任务加入等待队列。
        //等待当前任务4个任务有执行完毕的，再从队列取出继续执行
        //processors = 4
        //currentTime = 1605865379519，第 0 Runnable，使用线程pool-1-thread-1开始执行....//刚开始立即开启4个线程执行4个任务
        //currentTime = 1605865379521，第 1 Runnable，使用线程pool-1-thread-2开始执行....
        //currentTime = 1605865379522，第 2 Runnable，使用线程pool-1-thread-3开始执行....
        //currentTime = 1605865379524，第 3 Runnable，使用线程pool-1-thread-4开始执行....
        //currentTime = 1605865380520，第 0 Runnable，使用线程pool-1-thread-1执行完毕----//1执行完毕后
        //currentTime = 1605865380520，第 4 Runnable，使用线程pool-1-thread-1开始执行....//从阻塞队列取出第4个继续运行
        //currentTime = 1605865380526，第 2 Runnable，使用线程pool-1-thread-3执行完毕----
        //currentTime = 1605865380526，第 5 Runnable，使用线程pool-1-thread-3开始执行....
        //currentTime = 1605865380526，第 1 Runnable，使用线程pool-1-thread-2执行完毕----
        //currentTime = 1605865380526，第 6 Runnable，使用线程pool-1-thread-2开始执行....
        //currentTime = 1605865380528，第 3 Runnable，使用线程pool-1-thread-4执行完毕----
        //currentTime = 1605865380528，第 7 Runnable，使用线程pool-1-thread-4开始执行....
        //currentTime = 1605865381526，第 4 Runnable，使用线程pool-1-thread-1执行完毕----
        //currentTime = 1605865381526，第 8 Runnable，使用线程pool-1-thread-1开始执行....
        //currentTime = 1605865381530，第 5 Runnable，使用线程pool-1-thread-3执行完毕----
        //currentTime = 1605865381530，第 7 Runnable，使用线程pool-1-thread-4执行完毕----
        //currentTime = 1605865381530，第 6 Runnable，使用线程pool-1-thread-2执行完毕----
        //currentTime = 1605865381530，第 10 Runnable，使用线程pool-1-thread-4开始执行....
        //currentTime = 1605865381530，第 9 Runnable，使用线程pool-1-thread-3开始执行....
        //currentTime = 1605865381531，第 11 Runnable，使用线程pool-1-thread-2开始执行....
        //currentTime = 1605865382528，第 8 Runnable，使用线程pool-1-thread-1执行完毕----
        //currentTime = 1605865382528，第 12 Runnable，使用线程pool-1-thread-1开始执行....
        //currentTime = 1605865382536，第 11 Runnable，使用线程pool-1-thread-2执行完毕----
        //currentTime = 1605865382536，第 9 Runnable，使用线程pool-1-thread-3执行完毕----
        //currentTime = 1605865382536，第 10 Runnable，使用线程pool-1-thread-4执行完毕----
        //currentTime = 1605865382536，第 14 Runnable，使用线程pool-1-thread-3开始执行....
        //currentTime = 1605865382536，第 13 Runnable，使用线程pool-1-thread-2开始执行....
        //currentTime = 1605865382536，第 15 Runnable，使用线程pool-1-thread-4开始执行....
        //currentTime = 1605865383530，第 12 Runnable，使用线程pool-1-thread-1执行完毕----
        //currentTime = 1605865383530，第 16 Runnable，使用线程pool-1-thread-1开始执行....
        //currentTime = 1605865383537，第 14 Runnable，使用线程pool-1-thread-3执行完毕----
        //currentTime = 1605865383537，第 13 Runnable，使用线程pool-1-thread-2执行完毕----
        //currentTime = 1605865383537，第 15 Runnable，使用线程pool-1-thread-4执行完毕----
        //currentTime = 1605865383538，第 18 Runnable，使用线程pool-1-thread-2开始执行....
        //currentTime = 1605865383537，第 17 Runnable，使用线程pool-1-thread-3开始执行....
        //currentTime = 1605865383538，第 19 Runnable，使用线程pool-1-thread-4开始执行....
        //currentTime = 1605865384533，第 16 Runnable，使用线程pool-1-thread-1执行完毕----
        //currentTime = 1605865384533，第 20 Runnable，使用线程pool-1-thread-1开始执行....
        //currentTime = 1605865384538，第 18 Runnable，使用线程pool-1-thread-2执行完毕----
        //currentTime = 1605865384538，第 19 Runnable，使用线程pool-1-thread-4执行完毕----
        //currentTime = 1605865384539，第 17 Runnable，使用线程pool-1-thread-3执行完毕----
        //currentTime = 1605865385537，第 20 Runnable，使用线程pool-1-thread-1执行完毕----
        for (int i = 0; i < 60; i++) {
            fixedThreadPool.execute(new MyRunnable(i,1000));
            //休息10秒后，第20-40个任务执行，复用1、2、3、4个核心线程进行处理
            //currentTime = 1605865389526，第 21 Runnable，使用线程pool-1-thread-2开始执行....//1、2、3、4核心线程一直存在不会被销毁，有新任务继续复用
            //currentTime = 1605865389526，第 24 Runnable，使用线程pool-1-thread-1开始执行....
            //currentTime = 1605865389526，第 23 Runnable，使用线程pool-1-thread-3开始执行....
            //currentTime = 1605865389526，第 22 Runnable，使用线程pool-1-thread-4开始执行....//还是每次只能执行4个任务，其它的加入阻塞队列等待
            //currentTime = 1605865390527，第 21 Runnable，使用线程pool-1-thread-2执行完毕----
            //currentTime = 1605865390528，第 24 Runnable，使用线程pool-1-thread-1执行完毕----
            //currentTime = 1605865390528，第 22 Runnable，使用线程pool-1-thread-4执行完毕----
            //currentTime = 1605865390528，第 27 Runnable，使用线程pool-1-thread-4开始执行....
            //currentTime = 1605865390528，第 25 Runnable，使用线程pool-1-thread-2开始执行....
            //currentTime = 1605865390528，第 23 Runnable，使用线程pool-1-thread-3执行完毕----
            //currentTime = 1605865390528，第 26 Runnable，使用线程pool-1-thread-1开始执行....
            //currentTime = 1605865390528，第 28 Runnable，使用线程pool-1-thread-3开始执行....
            //currentTime = 1605865391530，第 26 Runnable，使用线程pool-1-thread-1执行完毕----
            //currentTime = 1605865391530，第 27 Runnable，使用线程pool-1-thread-4执行完毕----
            //currentTime = 1605865391530，第 28 Runnable，使用线程pool-1-thread-3执行完毕----
            //currentTime = 1605865391530，第 25 Runnable，使用线程pool-1-thread-2执行完毕----
            //currentTime = 1605865391531，第 31 Runnable，使用线程pool-1-thread-3开始执行....
            //currentTime = 1605865391531，第 30 Runnable，使用线程pool-1-thread-4开始执行....
            //currentTime = 1605865391530，第 29 Runnable，使用线程pool-1-thread-1开始执行....
            //currentTime = 1605865391531，第 32 Runnable，使用线程pool-1-thread-2开始执行....
            //currentTime = 1605865392534，第 30 Runnable，使用线程pool-1-thread-4执行完毕----
            //currentTime = 1605865392534，第 32 Runnable，使用线程pool-1-thread-2执行完毕----
            //currentTime = 1605865392534，第 29 Runnable，使用线程pool-1-thread-1执行完毕----
            //currentTime = 1605865392534，第 31 Runnable，使用线程pool-1-thread-3执行完毕----
            //currentTime = 1605865392534，第 35 Runnable，使用线程pool-1-thread-1开始执行....
            //currentTime = 1605865392534，第 34 Runnable，使用线程pool-1-thread-2开始执行....
            //currentTime = 1605865392534，第 33 Runnable，使用线程pool-1-thread-4开始执行....
            //currentTime = 1605865392534，第 36 Runnable，使用线程pool-1-thread-3开始执行....
            //currentTime = 1605865393537，第 35 Runnable，使用线程pool-1-thread-1执行完毕----
            //currentTime = 1605865393538，第 33 Runnable，使用线程pool-1-thread-4执行完毕----
            //currentTime = 1605865393537，第 34 Runnable，使用线程pool-1-thread-2执行完毕----
            //currentTime = 1605865393538，第 36 Runnable，使用线程pool-1-thread-3执行完毕----
            //currentTime = 1605865393538，第 39 Runnable，使用线程pool-1-thread-2开始执行....
            //currentTime = 1605865393538，第 38 Runnable，使用线程pool-1-thread-4开始执行....
            //currentTime = 1605865393538，第 37 Runnable，使用线程pool-1-thread-1开始执行....
            //currentTime = 1605865393538，第 40 Runnable，使用线程pool-1-thread-3开始执行....
            //currentTime = 1605865394542，第 38 Runnable，使用线程pool-1-thread-4执行完毕----
            //currentTime = 1605865394542，第 40 Runnable，使用线程pool-1-thread-3执行完毕----
            //currentTime = 1605865394542，第 39 Runnable，使用线程pool-1-thread-2执行完毕----
            //currentTime = 1605865394542，第 37 Runnable，使用线程pool-1-thread-1执行完毕----
            if (i == 20 || i == 40) {
                try {
                    Thread.sleep(10000);
                    System.out.println("--------------------------------");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
